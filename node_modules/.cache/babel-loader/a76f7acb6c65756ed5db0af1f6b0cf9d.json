{"ast":null,"code":"/* fichier simulant un backend qui stock des données\n  ici nous sauvegarderons les données dans le localStorage\n*/\nimport crypto from 'crypto';\nimport { TYPE_TV, TYPE_MOVIE } from '../config';\nconst localStorageKey = 'db-back-netflix-clone-users';\nconst localStorageKeyList = 'db-back-netflix-clone-users-savedlist';\n\nfunction loadUsers() {\n  const users = JSON.parse(window.localStorage.getItem(localStorageKey));\n  return users !== null && users !== void 0 ? users : [];\n}\n\nasync function loadUserById(id, cleanFields = false) {\n  const user = loadUsers().find(item => item.id === id);\n  return cleanFields && user ? clean(user) : user;\n}\n\nasync function saveUser(user) {\n  const users = loadUsers();\n  users.push(user);\n  saveUsers(users);\n}\n\nfunction saveUsers(users) {\n  window.localStorage.setItem(localStorageKey, JSON.stringify(users));\n}\n\nasync function createUser({\n  username,\n  password\n}) {\n  validateUser({\n    username,\n    password\n  });\n  const id = hashcode(username);\n  const passwordHash = hashcode(password);\n  const uid = await loadUserById(id);\n\n  if (uid) {\n    const error = new Error(`Impossible de créer un utilisateur car  \"${username}\" existe déjà `);\n    error.status = 400;\n    throw error;\n  }\n\n  const user = {\n    id,\n    username,\n    passwordHash\n  };\n  saveUser(user);\n  return await loadUserById(id);\n}\n\nfunction validateUser({\n  username,\n  password\n}) {\n  if (!username) {\n    const error = new Error(\"Le nom d'utilisateur est obligatoire\");\n    error.status = 400;\n    throw error;\n  }\n\n  if (!password) {\n    const error = new Error('Le mot de passe est obligatoire');\n    error.status = 400;\n    throw error;\n  }\n}\n\nfunction hashcode(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\nasync function authenticate({\n  username,\n  password\n}) {\n  validateUser({\n    username,\n    password\n  });\n  const id = hashcode(username);\n  const user = (await loadUserById(id)) || {};\n\n  if (user.passwordHash === hashcode(password)) {\n    return { ...clean(user),\n      token: Buffer.from(user.id).toString('base64')\n    };\n  }\n\n  const error = new Error(\"Nom d' utilisateur ou mot de passe incorrect\");\n  error.status = 400;\n  throw error;\n}\n\nfunction clean(user) {\n  if (user.passwordHash) {\n    const {\n      passwordHash,\n      ...rest\n    } = user;\n    return rest;\n  }\n}\n\nasync function updateUser(id, data) {\n  validateUser(id);\n  const user = await loadUserById(id);\n  Object.assign(user, data);\n  saveUser(user);\n  return await loadUserById(id);\n}\n\nasync function deleteUser(id) {\n  validateUser(id);\n  const user = await loadUserById(id);\n  const users = await loadUsers();\n  const updatedArray = users.filter(item => item.id !== user.id);\n  saveUsers(updatedArray);\n}\n\nasync function resetStorage() {\n  const users = {};\n  saveUser(users);\n}\n/**  Bookmark **/\n\n\nfunction loadAllUsersBookmarks() {\n  const all = JSON.parse(window.localStorage.getItem(localStorageKeyList));\n  return all !== null && all !== void 0 ? all : [];\n}\n\nasync function saveUserBookmark(savedList) {\n  let all = loadAllUsersBookmarks();\n  console.log('saveUserBookmark', all);\n  all = all.filter(item => item.uid !== savedList.uid);\n  all.push(savedList);\n  console.log('saveUserBookmark2', all);\n  saveAllUsersBookmarks(all);\n}\n\nfunction saveAllUsersBookmarks(allUidList) {\n  window.localStorage.setItem(localStorageKeyList, JSON.stringify(allUidList));\n}\n\nasync function loadBookmarkByUid(uid) {\n  //bookmark example => {uid: 1, movies: [1010, 1010, 5050],series:[6515,541]}\n  const bookmark = loadAllUsersBookmarks().find(item => item.uid === uid);\n  return bookmark !== null && bookmark !== void 0 ? bookmark : {\n    uid,\n    movies: [],\n    series: []\n  };\n}\n\nasync function addMovieToBookmark(movieId, uid) {\n  await addToBookmark(movieId, uid, TYPE_MOVIE);\n}\n\nasync function addSerieToBookmark(tvId, uid) {\n  await addToBookmark(tvId, uid, TYPE_TV);\n}\n\nasync function addToBookmark(ui, uid, type = TYPE_TV) {\n  const bookmark = await loadBookmarkByUid(uid);\n  await checkBookMark(ui, uid, type);\n\n  if (type === TYPE_TV) {\n    bookmark.series.push(ui);\n  } else {\n    bookmark.movies.push(ui);\n  }\n\n  saveUserBookmark(bookmark);\n}\n\nasync function deleteMovieToBookmark(movieId, uid) {\n  await deleteToBookmark(movieId, uid, TYPE_MOVIE);\n}\n\nasync function deleteSerieToBookmark(tvId, uid) {\n  await deleteToBookmark(tvId, uid, TYPE_TV);\n}\n\nasync function deleteToBookmark(id, uid, type = TYPE_TV) {\n  const bookmark = await loadBookmarkByUid(uid);\n\n  if (type === TYPE_TV) {\n    const series = bookmark.series.filter(item => item !== id);\n    bookmark.series = series;\n    console.log('deleteToBookmark', series);\n  } else {\n    const movies = bookmark.movies.filter(item => item !== id);\n    console.log('deleteToBookmark movies', movies);\n    bookmark.movies = movies;\n  }\n\n  saveUserBookmark(bookmark);\n}\n\nasync function checkBookMark(id, uid, type = TYPE_TV) {\n  const bookmark = await loadBookmarkByUid(uid);\n\n  if (type === TYPE_TV) {\n    const serie = bookmark.series.find(item => item === id);\n\n    if (serie > 0) {\n      const error = new Error('Serie déjà dans la liste');\n      error.status = 400;\n      throw error;\n    }\n  } else {\n    const movie = bookmark.movies.find(item => item === id);\n\n    if (movie) {\n      const error = new Error('Film déjà dans la liste');\n      error.status = 400;\n      throw error;\n    }\n  }\n}\n\nexport { addMovieToBookmark, addSerieToBookmark, loadBookmarkByUid, deleteMovieToBookmark, deleteSerieToBookmark, authenticate, createUser, loadUserById, updateUser, deleteUser, resetStorage };","map":{"version":3,"sources":["/Users/lio/Documents/Programmation/React-MikeC/react-netflix-clone/src/mocks/db.js"],"names":["crypto","TYPE_TV","TYPE_MOVIE","localStorageKey","localStorageKeyList","loadUsers","users","JSON","parse","window","localStorage","getItem","loadUserById","id","cleanFields","user","find","item","clean","saveUser","push","saveUsers","setItem","stringify","createUser","username","password","validateUser","hashcode","passwordHash","uid","error","Error","status","data","createHash","update","digest","authenticate","token","Buffer","from","toString","rest","updateUser","Object","assign","deleteUser","updatedArray","filter","resetStorage","loadAllUsersBookmarks","all","saveUserBookmark","savedList","console","log","saveAllUsersBookmarks","allUidList","loadBookmarkByUid","bookmark","movies","series","addMovieToBookmark","movieId","addToBookmark","addSerieToBookmark","tvId","ui","type","checkBookMark","deleteMovieToBookmark","deleteToBookmark","deleteSerieToBookmark","serie","movie"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,MAAP,MAAmB,QAAnB;AACA,SAAQC,OAAR,EAAiBC,UAAjB,QAAkC,WAAlC;AACA,MAAMC,eAAe,GAAG,6BAAxB;AACA,MAAMC,mBAAmB,GAAG,uCAA5B;;AAEA,SAASC,SAAT,GAAqB;AACnB,QAAMC,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWC,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4BR,eAA5B,CAAX,CAAd;AACA,SAAOG,KAAP,aAAOA,KAAP,cAAOA,KAAP,GAAgB,EAAhB;AACD;;AAED,eAAeM,YAAf,CAA4BC,EAA5B,EAAgCC,WAAW,GAAG,KAA9C,EAAqD;AACnD,QAAMC,IAAI,GAAGV,SAAS,GAAGW,IAAZ,CAAiBC,IAAI,IAAIA,IAAI,CAACJ,EAAL,KAAYA,EAArC,CAAb;AACA,SAAOC,WAAW,IAAIC,IAAf,GAAsBG,KAAK,CAACH,IAAD,CAA3B,GAAoCA,IAA3C;AACD;;AAED,eAAeI,QAAf,CAAwBJ,IAAxB,EAA8B;AAC5B,QAAMT,KAAK,GAAGD,SAAS,EAAvB;AACAC,EAAAA,KAAK,CAACc,IAAN,CAAWL,IAAX;AACAM,EAAAA,SAAS,CAACf,KAAD,CAAT;AACD;;AAED,SAASe,SAAT,CAAmBf,KAAnB,EAA0B;AACxBG,EAAAA,MAAM,CAACC,YAAP,CAAoBY,OAApB,CAA4BnB,eAA5B,EAA6CI,IAAI,CAACgB,SAAL,CAAejB,KAAf,CAA7C;AACD;;AAED,eAAekB,UAAf,CAA0B;AAACC,EAAAA,QAAD;AAAWC,EAAAA;AAAX,CAA1B,EAAgD;AAC9CC,EAAAA,YAAY,CAAC;AAACF,IAAAA,QAAD;AAAWC,IAAAA;AAAX,GAAD,CAAZ;AACA,QAAMb,EAAE,GAAGe,QAAQ,CAACH,QAAD,CAAnB;AACA,QAAMI,YAAY,GAAGD,QAAQ,CAACF,QAAD,CAA7B;AACA,QAAMI,GAAG,GAAG,MAAMlB,YAAY,CAACC,EAAD,CAA9B;;AACA,MAAIiB,GAAJ,EAAS;AACP,UAAMC,KAAK,GAAG,IAAIC,KAAJ,CACX,4CAA2CP,QAAS,gBADzC,CAAd;AAGAM,IAAAA,KAAK,CAACE,MAAN,GAAe,GAAf;AACA,UAAMF,KAAN;AACD;;AACD,QAAMhB,IAAI,GAAG;AAACF,IAAAA,EAAD;AAAKY,IAAAA,QAAL;AAAeI,IAAAA;AAAf,GAAb;AACAV,EAAAA,QAAQ,CAACJ,IAAD,CAAR;AACA,SAAO,MAAMH,YAAY,CAACC,EAAD,CAAzB;AACD;;AAED,SAASc,YAAT,CAAsB;AAACF,EAAAA,QAAD;AAAWC,EAAAA;AAAX,CAAtB,EAA4C;AAC1C,MAAI,CAACD,QAAL,EAAe;AACb,UAAMM,KAAK,GAAG,IAAIC,KAAJ,CAAU,sCAAV,CAAd;AACAD,IAAAA,KAAK,CAACE,MAAN,GAAe,GAAf;AACA,UAAMF,KAAN;AACD;;AACD,MAAI,CAACL,QAAL,EAAe;AACb,UAAMK,KAAK,GAAG,IAAIC,KAAJ,CAAU,iCAAV,CAAd;AACAD,IAAAA,KAAK,CAACE,MAAN,GAAe,GAAf;AACA,UAAMF,KAAN;AACD;AACF;;AAED,SAASH,QAAT,CAAkBM,IAAlB,EAAwB;AACtB,SAAOlC,MAAM,CAACmC,UAAP,CAAkB,KAAlB,EAAyBC,MAAzB,CAAgCF,IAAhC,EAAsCG,MAAtC,CAA6C,KAA7C,CAAP;AACD;;AAED,eAAeC,YAAf,CAA4B;AAACb,EAAAA,QAAD;AAAWC,EAAAA;AAAX,CAA5B,EAAkD;AAChDC,EAAAA,YAAY,CAAC;AAACF,IAAAA,QAAD;AAAWC,IAAAA;AAAX,GAAD,CAAZ;AACA,QAAMb,EAAE,GAAGe,QAAQ,CAACH,QAAD,CAAnB;AACA,QAAMV,IAAI,GAAG,CAAC,MAAMH,YAAY,CAACC,EAAD,CAAnB,KAA4B,EAAzC;;AACA,MAAIE,IAAI,CAACc,YAAL,KAAsBD,QAAQ,CAACF,QAAD,CAAlC,EAA8C;AAC5C,WAAO,EAAC,GAAGR,KAAK,CAACH,IAAD,CAAT;AAAiBwB,MAAAA,KAAK,EAAEC,MAAM,CAACC,IAAP,CAAY1B,IAAI,CAACF,EAAjB,EAAqB6B,QAArB,CAA8B,QAA9B;AAAxB,KAAP;AACD;;AACD,QAAMX,KAAK,GAAG,IAAIC,KAAJ,CAAU,8CAAV,CAAd;AACAD,EAAAA,KAAK,CAACE,MAAN,GAAe,GAAf;AACA,QAAMF,KAAN;AACD;;AACD,SAASb,KAAT,CAAeH,IAAf,EAAqB;AACnB,MAAIA,IAAI,CAACc,YAAT,EAAuB;AACrB,UAAM;AAACA,MAAAA,YAAD;AAAe,SAAGc;AAAlB,QAA0B5B,IAAhC;AACA,WAAO4B,IAAP;AACD;AACF;;AACD,eAAeC,UAAf,CAA0B/B,EAA1B,EAA8BqB,IAA9B,EAAoC;AAClCP,EAAAA,YAAY,CAACd,EAAD,CAAZ;AACA,QAAME,IAAI,GAAG,MAAMH,YAAY,CAACC,EAAD,CAA/B;AACAgC,EAAAA,MAAM,CAACC,MAAP,CAAc/B,IAAd,EAAoBmB,IAApB;AACAf,EAAAA,QAAQ,CAACJ,IAAD,CAAR;AACA,SAAO,MAAMH,YAAY,CAACC,EAAD,CAAzB;AACD;;AACD,eAAekC,UAAf,CAA0BlC,EAA1B,EAA8B;AAC5Bc,EAAAA,YAAY,CAACd,EAAD,CAAZ;AACA,QAAME,IAAI,GAAG,MAAMH,YAAY,CAACC,EAAD,CAA/B;AACA,QAAMP,KAAK,GAAG,MAAMD,SAAS,EAA7B;AACA,QAAM2C,YAAY,GAAG1C,KAAK,CAAC2C,MAAN,CAAahC,IAAI,IAAIA,IAAI,CAACJ,EAAL,KAAYE,IAAI,CAACF,EAAtC,CAArB;AACAQ,EAAAA,SAAS,CAAC2B,YAAD,CAAT;AACD;;AAED,eAAeE,YAAf,GAA8B;AAC5B,QAAM5C,KAAK,GAAG,EAAd;AACAa,EAAAA,QAAQ,CAACb,KAAD,CAAR;AACD;AACD;;;AAEA,SAAS6C,qBAAT,GAAiC;AAC/B,QAAMC,GAAG,GAAG7C,IAAI,CAACC,KAAL,CAAWC,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4BP,mBAA5B,CAAX,CAAZ;AACA,SAAOgD,GAAP,aAAOA,GAAP,cAAOA,GAAP,GAAc,EAAd;AACD;;AAED,eAAeC,gBAAf,CAAgCC,SAAhC,EAA2C;AACzC,MAAIF,GAAG,GAAGD,qBAAqB,EAA/B;AACAI,EAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ,EAAgCJ,GAAhC;AACAA,EAAAA,GAAG,GAAGA,GAAG,CAACH,MAAJ,CAAWhC,IAAI,IAAIA,IAAI,CAACa,GAAL,KAAawB,SAAS,CAACxB,GAA1C,CAAN;AACAsB,EAAAA,GAAG,CAAChC,IAAJ,CAASkC,SAAT;AAEAC,EAAAA,OAAO,CAACC,GAAR,CAAY,mBAAZ,EAAiCJ,GAAjC;AACAK,EAAAA,qBAAqB,CAACL,GAAD,CAArB;AACD;;AAED,SAASK,qBAAT,CAA+BC,UAA/B,EAA2C;AACzCjD,EAAAA,MAAM,CAACC,YAAP,CAAoBY,OAApB,CAA4BlB,mBAA5B,EAAiDG,IAAI,CAACgB,SAAL,CAAemC,UAAf,CAAjD;AACD;;AACD,eAAeC,iBAAf,CAAiC7B,GAAjC,EAAsC;AACpC;AACA,QAAM8B,QAAQ,GAAGT,qBAAqB,GAAGnC,IAAxB,CAA6BC,IAAI,IAAIA,IAAI,CAACa,GAAL,KAAaA,GAAlD,CAAjB;AACA,SAAO8B,QAAP,aAAOA,QAAP,cAAOA,QAAP,GAAmB;AAAC9B,IAAAA,GAAD;AAAM+B,IAAAA,MAAM,EAAE,EAAd;AAAkBC,IAAAA,MAAM,EAAE;AAA1B,GAAnB;AACD;;AAED,eAAeC,kBAAf,CAAkCC,OAAlC,EAA2ClC,GAA3C,EAAgD;AAC9C,QAAMmC,aAAa,CAACD,OAAD,EAAUlC,GAAV,EAAe5B,UAAf,CAAnB;AACD;;AAED,eAAegE,kBAAf,CAAkCC,IAAlC,EAAwCrC,GAAxC,EAA6C;AAC3C,QAAMmC,aAAa,CAACE,IAAD,EAAOrC,GAAP,EAAY7B,OAAZ,CAAnB;AACD;;AACD,eAAegE,aAAf,CAA6BG,EAA7B,EAAiCtC,GAAjC,EAAsCuC,IAAI,GAAGpE,OAA7C,EAAsD;AACpD,QAAM2D,QAAQ,GAAG,MAAMD,iBAAiB,CAAC7B,GAAD,CAAxC;AACA,QAAMwC,aAAa,CAACF,EAAD,EAAKtC,GAAL,EAAUuC,IAAV,CAAnB;;AACA,MAAIA,IAAI,KAAKpE,OAAb,EAAsB;AACpB2D,IAAAA,QAAQ,CAACE,MAAT,CAAgB1C,IAAhB,CAAqBgD,EAArB;AACD,GAFD,MAEO;AACLR,IAAAA,QAAQ,CAACC,MAAT,CAAgBzC,IAAhB,CAAqBgD,EAArB;AACD;;AACDf,EAAAA,gBAAgB,CAACO,QAAD,CAAhB;AACD;;AAED,eAAeW,qBAAf,CAAqCP,OAArC,EAA8ClC,GAA9C,EAAmD;AACjD,QAAM0C,gBAAgB,CAACR,OAAD,EAAUlC,GAAV,EAAe5B,UAAf,CAAtB;AACD;;AACD,eAAeuE,qBAAf,CAAqCN,IAArC,EAA2CrC,GAA3C,EAAgD;AAC9C,QAAM0C,gBAAgB,CAACL,IAAD,EAAOrC,GAAP,EAAY7B,OAAZ,CAAtB;AACD;;AAED,eAAeuE,gBAAf,CAAgC3D,EAAhC,EAAoCiB,GAApC,EAAyCuC,IAAI,GAAGpE,OAAhD,EAAyD;AACvD,QAAM2D,QAAQ,GAAG,MAAMD,iBAAiB,CAAC7B,GAAD,CAAxC;;AACA,MAAIuC,IAAI,KAAKpE,OAAb,EAAsB;AACpB,UAAM6D,MAAM,GAAGF,QAAQ,CAACE,MAAT,CAAgBb,MAAhB,CAAuBhC,IAAI,IAAIA,IAAI,KAAKJ,EAAxC,CAAf;AACA+C,IAAAA,QAAQ,CAACE,MAAT,GAAkBA,MAAlB;AACAP,IAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ,EAAgCM,MAAhC;AACD,GAJD,MAIO;AACL,UAAMD,MAAM,GAAGD,QAAQ,CAACC,MAAT,CAAgBZ,MAAhB,CAAuBhC,IAAI,IAAIA,IAAI,KAAKJ,EAAxC,CAAf;AACA0C,IAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ,EAAuCK,MAAvC;AACAD,IAAAA,QAAQ,CAACC,MAAT,GAAkBA,MAAlB;AACD;;AACDR,EAAAA,gBAAgB,CAACO,QAAD,CAAhB;AACD;;AAED,eAAeU,aAAf,CAA6BzD,EAA7B,EAAiCiB,GAAjC,EAAsCuC,IAAI,GAAGpE,OAA7C,EAAsD;AACpD,QAAM2D,QAAQ,GAAG,MAAMD,iBAAiB,CAAC7B,GAAD,CAAxC;;AACA,MAAIuC,IAAI,KAAKpE,OAAb,EAAsB;AACpB,UAAMyE,KAAK,GAAGd,QAAQ,CAACE,MAAT,CAAgB9C,IAAhB,CAAqBC,IAAI,IAAIA,IAAI,KAAKJ,EAAtC,CAAd;;AACA,QAAI6D,KAAK,GAAG,CAAZ,EAAe;AACb,YAAM3C,KAAK,GAAG,IAAIC,KAAJ,CAAU,0BAAV,CAAd;AACAD,MAAAA,KAAK,CAACE,MAAN,GAAe,GAAf;AACA,YAAMF,KAAN;AACD;AACF,GAPD,MAOO;AACL,UAAM4C,KAAK,GAAGf,QAAQ,CAACC,MAAT,CAAgB7C,IAAhB,CAAqBC,IAAI,IAAIA,IAAI,KAAKJ,EAAtC,CAAd;;AACA,QAAI8D,KAAJ,EAAW;AACT,YAAM5C,KAAK,GAAG,IAAIC,KAAJ,CAAU,yBAAV,CAAd;AACAD,MAAAA,KAAK,CAACE,MAAN,GAAe,GAAf;AACA,YAAMF,KAAN;AACD;AACF;AACF;;AAED,SACEgC,kBADF,EAEEG,kBAFF,EAGEP,iBAHF,EAIEY,qBAJF,EAKEE,qBALF,EAMEnC,YANF,EAOEd,UAPF,EAQEZ,YARF,EASEgC,UATF,EAUEG,UAVF,EAWEG,YAXF","sourcesContent":["/* fichier simulant un backend qui stock des données\n  ici nous sauvegarderons les données dans le localStorage\n*/\nimport crypto from 'crypto'\nimport {TYPE_TV, TYPE_MOVIE} from '../config'\nconst localStorageKey = 'db-back-netflix-clone-users'\nconst localStorageKeyList = 'db-back-netflix-clone-users-savedlist'\n\nfunction loadUsers() {\n  const users = JSON.parse(window.localStorage.getItem(localStorageKey))\n  return users ?? []\n}\n\nasync function loadUserById(id, cleanFields = false) {\n  const user = loadUsers().find(item => item.id === id)\n  return cleanFields && user ? clean(user) : user\n}\n\nasync function saveUser(user) {\n  const users = loadUsers()\n  users.push(user)\n  saveUsers(users)\n}\n\nfunction saveUsers(users) {\n  window.localStorage.setItem(localStorageKey, JSON.stringify(users))\n}\n\nasync function createUser({username, password}) {\n  validateUser({username, password})\n  const id = hashcode(username)\n  const passwordHash = hashcode(password)\n  const uid = await loadUserById(id)\n  if (uid) {\n    const error = new Error(\n      `Impossible de créer un utilisateur car  \"${username}\" existe déjà `,\n    )\n    error.status = 400\n    throw error\n  }\n  const user = {id, username, passwordHash}\n  saveUser(user)\n  return await loadUserById(id)\n}\n\nfunction validateUser({username, password}) {\n  if (!username) {\n    const error = new Error(\"Le nom d'utilisateur est obligatoire\")\n    error.status = 400\n    throw error\n  }\n  if (!password) {\n    const error = new Error('Le mot de passe est obligatoire')\n    error.status = 400\n    throw error\n  }\n}\n\nfunction hashcode(data) {\n  return crypto.createHash('md5').update(data).digest('hex')\n}\n\nasync function authenticate({username, password}) {\n  validateUser({username, password})\n  const id = hashcode(username)\n  const user = (await loadUserById(id)) || {}\n  if (user.passwordHash === hashcode(password)) {\n    return {...clean(user), token: Buffer.from(user.id).toString('base64')}\n  }\n  const error = new Error(\"Nom d' utilisateur ou mot de passe incorrect\")\n  error.status = 400\n  throw error\n}\nfunction clean(user) {\n  if (user.passwordHash) {\n    const {passwordHash, ...rest} = user\n    return rest\n  }\n}\nasync function updateUser(id, data) {\n  validateUser(id)\n  const user = await loadUserById(id)\n  Object.assign(user, data)\n  saveUser(user)\n  return await loadUserById(id)\n}\nasync function deleteUser(id) {\n  validateUser(id)\n  const user = await loadUserById(id)\n  const users = await loadUsers()\n  const updatedArray = users.filter(item => item.id !== user.id)\n  saveUsers(updatedArray)\n}\n\nasync function resetStorage() {\n  const users = {}\n  saveUser(users)\n}\n/**  Bookmark **/\n\nfunction loadAllUsersBookmarks() {\n  const all = JSON.parse(window.localStorage.getItem(localStorageKeyList))\n  return all ?? []\n}\n\nasync function saveUserBookmark(savedList) {\n  let all = loadAllUsersBookmarks()\n  console.log('saveUserBookmark', all)\n  all = all.filter(item => item.uid !== savedList.uid)\n  all.push(savedList)\n\n  console.log('saveUserBookmark2', all)\n  saveAllUsersBookmarks(all)\n}\n\nfunction saveAllUsersBookmarks(allUidList) {\n  window.localStorage.setItem(localStorageKeyList, JSON.stringify(allUidList))\n}\nasync function loadBookmarkByUid(uid) {\n  //bookmark example => {uid: 1, movies: [1010, 1010, 5050],series:[6515,541]}\n  const bookmark = loadAllUsersBookmarks().find(item => item.uid === uid)\n  return bookmark ?? {uid, movies: [], series: []}\n}\n\nasync function addMovieToBookmark(movieId, uid) {\n  await addToBookmark(movieId, uid, TYPE_MOVIE)\n}\n\nasync function addSerieToBookmark(tvId, uid) {\n  await addToBookmark(tvId, uid, TYPE_TV)\n}\nasync function addToBookmark(ui, uid, type = TYPE_TV) {\n  const bookmark = await loadBookmarkByUid(uid)\n  await checkBookMark(ui, uid, type)\n  if (type === TYPE_TV) {\n    bookmark.series.push(ui)\n  } else {\n    bookmark.movies.push(ui)\n  }\n  saveUserBookmark(bookmark)\n}\n\nasync function deleteMovieToBookmark(movieId, uid) {\n  await deleteToBookmark(movieId, uid, TYPE_MOVIE)\n}\nasync function deleteSerieToBookmark(tvId, uid) {\n  await deleteToBookmark(tvId, uid, TYPE_TV)\n}\n\nasync function deleteToBookmark(id, uid, type = TYPE_TV) {\n  const bookmark = await loadBookmarkByUid(uid)\n  if (type === TYPE_TV) {\n    const series = bookmark.series.filter(item => item !== id)\n    bookmark.series = series\n    console.log('deleteToBookmark', series)\n  } else {\n    const movies = bookmark.movies.filter(item => item !== id)\n    console.log('deleteToBookmark movies', movies)\n    bookmark.movies = movies\n  }\n  saveUserBookmark(bookmark)\n}\n\nasync function checkBookMark(id, uid, type = TYPE_TV) {\n  const bookmark = await loadBookmarkByUid(uid)\n  if (type === TYPE_TV) {\n    const serie = bookmark.series.find(item => item === id)\n    if (serie > 0) {\n      const error = new Error('Serie déjà dans la liste')\n      error.status = 400\n      throw error\n    }\n  } else {\n    const movie = bookmark.movies.find(item => item === id)\n    if (movie) {\n      const error = new Error('Film déjà dans la liste')\n      error.status = 400\n      throw error\n    }\n  }\n}\n\nexport {\n  addMovieToBookmark,\n  addSerieToBookmark,\n  loadBookmarkByUid,\n  deleteMovieToBookmark,\n  deleteSerieToBookmark,\n  authenticate,\n  createUser,\n  loadUserById,\n  updateUser,\n  deleteUser,\n  resetStorage,\n}\n"]},"metadata":{},"sourceType":"module"}