{"ast":null,"code":"/* fichier simulant un backend qui stock des données\n  ici nous sauvegarderons les données dans le localStorage\n*/\nimport crypto from 'crypto';\nconst localStorageKey = 'netflix-clone-users';\n\nfunction loadUsers() {\n  const users = JSON.parse(window.localStorage.getItem(localStorageKey));\n  return users !== null && users !== void 0 ? users : [];\n}\n\nasync function loadUserById(id, cleanFields = false) {\n  const user = loadUsers().find(item => item.id === id);\n  return cleanFields && user ? clean(user) : user;\n}\n\nasync function saveUser(user) {\n  const users = loadUsers();\n  users.push(user);\n  saveUsers(users);\n}\n\nfunction saveUsers(users) {\n  window.localStorage.setItem(localStorageKey, JSON.stringify(users));\n}\n\nasync function createUser({\n  username,\n  password\n}) {\n  validateUser({\n    username,\n    password\n  });\n  const id = hashcode(username);\n  const passwordHash = hashcode(password);\n  const uid = await loadUserById(id);\n\n  if (uid) {\n    const error = new Error(`Impossible de créer un utilisateur car  \"${username}\" existe déjà `);\n    error.status = 400;\n    throw error;\n  }\n\n  const user = {\n    id,\n    username,\n    passwordHash\n  };\n  saveUser(user);\n  return await loadUserById(id);\n}\n\nfunction validateUser({\n  username,\n  password\n}) {\n  if (!username) {\n    const error = new Error(\"Le nom d'utilisateur est obligatoire\");\n    error.status = 400;\n    throw error;\n  }\n\n  if (!password) {\n    const error = new Error('Le mot de passe est obligatoire');\n    error.status = 400;\n    throw error;\n  }\n}\n\nfunction hashcode(data) {\n  return crypto.createHash('md5').update(data).digest('hex');\n}\n\nasync function authenticate({\n  username,\n  password\n}) {\n  validateUser({\n    username,\n    password\n  });\n  const id = hashcode(username);\n  const user = (await loadUserById(id)) || {};\n\n  if (user.passwordHash === hashcode(password)) {\n    return { ...clean(user),\n      token: Buffer.from(user.id).toString('base64')\n    };\n  }\n\n  const error = new Error(\"Nom d' utilisateur ou mot de passe incorrect\");\n  error.status = 400;\n  throw error;\n}\n\nfunction clean(user) {\n  if (user.passwordHash) {\n    const {\n      passwordHash,\n      ...rest\n    } = user;\n    return rest;\n  }\n}\n\nasync function updateUser(id, data) {\n  validateUser(id);\n  const user = await loadUserById(id);\n  Object.assign(user, data);\n  saveUser(user);\n  return await loadUserById(id);\n}\n\nasync function deleteUser(id) {\n  validateUser(id);\n  const user = await loadUserById(id);\n  const users = await loadUsers();\n  const updatedArray = users.filter(item => item.id !== user.id);\n  saveUsers(updatedArray);\n}\n\nasync function resetStorage() {\n  const users = {};\n  saveUser(users);\n}\n\nexport { authenticate, createUser, loadUserById, updateUser, deleteUser, resetStorage };","map":{"version":3,"sources":["/Users/lio/Documents/Programmation/React-MikeC/react-netflix-clone/src/mocks/db.js"],"names":["crypto","localStorageKey","loadUsers","users","JSON","parse","window","localStorage","getItem","loadUserById","id","cleanFields","user","find","item","clean","saveUser","push","saveUsers","setItem","stringify","createUser","username","password","validateUser","hashcode","passwordHash","uid","error","Error","status","data","createHash","update","digest","authenticate","token","Buffer","from","toString","rest","updateUser","Object","assign","deleteUser","updatedArray","filter","resetStorage"],"mappings":"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","sourcesContent":["/* fichier simulant un backend qui stock des données\n  ici nous sauvegarderons les données dans le localStorage\n*/\nimport crypto from 'crypto'\nconst localStorageKey = 'netflix-clone-users'\n\nfunction loadUsers() {\n  const users = JSON.parse(window.localStorage.getItem(localStorageKey))\n  return users ?? []\n}\n\nasync function loadUserById(id, cleanFields = false) {\n  const user = loadUsers().find(item => item.id === id)\n  return cleanFields && user ? clean(user) : user\n}\n\nasync function saveUser(user) {\n  const users = loadUsers()\n  users.push(user)\n  saveUsers(users)\n}\n\nfunction saveUsers(users) {\n  window.localStorage.setItem(localStorageKey, JSON.stringify(users))\n}\n\nasync function createUser({username, password}) {\n  validateUser({username, password})\n  const id = hashcode(username)\n  const passwordHash = hashcode(password)\n  const uid = await loadUserById(id)\n  if (uid) {\n    const error = new Error(\n      `Impossible de créer un utilisateur car  \"${username}\" existe déjà `,\n    )\n    error.status = 400\n    throw error\n  }\n  const user = {id, username, passwordHash}\n  saveUser(user)\n  return await loadUserById(id)\n}\n\nfunction validateUser({username, password}) {\n  if (!username) {\n    const error = new Error(\"Le nom d'utilisateur est obligatoire\")\n    error.status = 400\n    throw error\n  }\n  if (!password) {\n    const error = new Error('Le mot de passe est obligatoire')\n    error.status = 400\n    throw error\n  }\n}\n\nfunction hashcode(data) {\n  return crypto.createHash('md5').update(data).digest('hex')\n}\n\nasync function authenticate({username, password}) {\n  validateUser({username, password})\n  const id = hashcode(username)\n  const user = (await loadUserById(id)) || {}\n  if (user.passwordHash === hashcode(password)) {\n    return {...clean(user), token: Buffer.from(user.id).toString('base64')}\n  }\n  const error = new Error(\"Nom d' utilisateur ou mot de passe incorrect\")\n  error.status = 400\n  throw error\n}\nfunction clean(user) {\n  if (user.passwordHash) {\n    const {passwordHash, ...rest} = user\n    return rest\n  }\n}\nasync function updateUser(id, data) {\n  validateUser(id)\n  const user = await loadUserById(id)\n  Object.assign(user, data)\n  saveUser(user)\n  return await loadUserById(id)\n}\nasync function deleteUser(id) {\n  validateUser(id)\n  const user = await loadUserById(id)\n  const users = await loadUsers()\n  const updatedArray = users.filter(item => item.id !== user.id)\n  saveUsers(updatedArray)\n}\n\nasync function resetStorage() {\n  const users = {}\n  saveUser(users)\n}\n\nexport {\n  authenticate,\n  createUser,\n  loadUserById,\n  updateUser,\n  deleteUser,\n  resetStorage,\n}\n"]},"metadata":{},"sourceType":"module"}