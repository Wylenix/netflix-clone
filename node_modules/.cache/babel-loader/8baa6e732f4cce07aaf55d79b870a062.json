{"ast":null,"code":"var _jsxFileName = \"/Users/lio/Documents/Programmation/React-MikeC/react-netflix-clone/src/components/NetflixBookmark.exercise.js\",\n    _s = $RefreshSig$();\n\nimport * as React from 'react'; // 🐶 importe les ressouces suivantes :\n// import {NetflixAppBar} from './NetflixAppBar'\n// import {NetflixHeader} from './NetflixHeader'\n// import {useFetchData} from '../utils/hooks'\n// import {clientNetFlix, clientApi} from '../utils/clientApi'\n// import * as authNetflix from '../utils/authNetflixProvider'\n// import {TYPE_MOVIE, TYPE_TV, imagePath400} from '../config'\n\nimport { Link } from 'react-router-dom'; // 🐶 'NetflixBookmark' devra faire deux appels API\n// 1. Le premier vers `bookmark` pour recuperer les favorie\n// 2. Un appel vers API TMDB pour afficher le header\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nconst NetflixBookmark = () => {\n  _s();\n\n  // 🐶 utilise le hook 'useFetchData' et ''useEffect'' pour appeler `bookmark`\n  // 🤖 const {data, execute}\n  // 🐶 utilise a nouveau le hook 'useFetchData' et ''useEffect'' pour appeler `TMDV`\n  // pour eviter la collision de nom nous créons des alias pour 'data' et 'execute'\n  // 🤖 const {data: headerMovie, execute: executeHeader}\n  // 🐶 appelle 'bookmark' en utilisant\n  React.useEffect(() => {// - execute et clientNetFlix\n    // - await authNetflix.getToken()\n  }, []); // 🐶 appelle 'api TMDB' APRES le premier appelle à 'bookmark' grace à la dependance 'data'\n  // et utilise :\n\n  React.useEffect(() => {// - executeHeader et clientApi\n    // 🐶 utilise le premier films de la liste pour l'appel API TMBD sinon la le film 749274\n    // 🤖 const id = data?.movies?.[0] ?? 749274\n  }, []);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"row\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"Films favoris\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 43,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"row__posters\",\n        children: /*#__PURE__*/_jsxDEV(Card, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 47,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 44,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 42,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"row\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: \"S\\xE9ries favorites\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 52,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"row__posters\",\n        children: /*#__PURE__*/_jsxDEV(Card, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 56,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 53,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 51,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n}; // 🐶 Le composant 'Card' à le même rendu que 'NetflixRow'\n// La difference est qu'au lieu de passer le 'movie' en prop, on passera l'id en props\n// Ensuite avec ce 'id' il faudra appeler l'api TMBD et afficher les donneés.\n\n\n_s(NetflixBookmark, \"3ubReDTFssvu4DHeldAg55cW/CI=\");\n\n_c = NetflixBookmark;\n\nconst Card = ({\n  id,\n  type,\n  watermark,\n  wideImage\n}) => {\n  // 🐶 Créé un state 'image' qui sera mis à jour image' après l'appel d'API\n  // 🐶 Fais l'appel API `${type}/${id}`\n  // 🐶 utilise useEffect avec la dependance sur 'data' pour mettre à jour l'image\n  // rappel de la fonction 'buildImagePath'\n  // 🤖\n  // const buildImagePath = data => {\n  //   const image = wideImage ? data?.backdrop_path : data?.poster_path\n  //   return image ? `${imagePath400}${image}` : null\n  // }\n  const watermarkClass = watermark ? 'watermarked' : '';\n  return /*#__PURE__*/_jsxDEV(Link, {\n    to: `/${type}/${id}`,\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: `row__poster row__posterLarge ${watermarkClass}`,\n      children: /*#__PURE__*/_jsxDEV(\"img\", {\n        src: \"\",\n        alt: \"\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 82,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 80,\n      columnNumber: 7\n    }, this)\n  }, id, false, {\n    fileName: _jsxFileName,\n    lineNumber: 79,\n    columnNumber: 5\n  }, this);\n};\n\n_c2 = Card;\nexport { NetflixBookmark };\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"NetflixBookmark\");\n$RefreshReg$(_c2, \"Card\");","map":{"version":3,"sources":["/Users/lio/Documents/Programmation/React-MikeC/react-netflix-clone/src/components/NetflixBookmark.exercise.js"],"names":["React","Link","NetflixBookmark","useEffect","Card","id","type","watermark","wideImage","watermarkClass"],"mappings":";;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB,C,CACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAAQC,IAAR,QAAmB,kBAAnB,C,CAEA;AACA;AACA;;;;;AACA,MAAMC,eAAe,GAAG,MAAM;AAAA;;AAC5B;AACA;AAEA;AACA;AACA;AAEA;AACAF,EAAAA,KAAK,CAACG,SAAN,CAAgB,MAAM,CACpB;AACA;AACD,GAHD,EAGG,EAHH,EAT4B,CAc5B;AACA;;AACAH,EAAAA,KAAK,CAACG,SAAN,CAAgB,MAAM,CACpB;AACA;AACA;AACD,GAJD,EAIG,EAJH;AAMA,sBACE;AAAA,4BAKE;AAAK,MAAA,SAAS,EAAC,KAAf;AAAA,8BACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cADF,eAEE;AAAK,QAAA,SAAS,EAAC,cAAf;AAAA,+BAGE,QAAC,IAAD;AAAA;AAAA;AAAA;AAAA;AAHF;AAAA;AAAA;AAAA;AAAA,cAFF;AAAA;AAAA;AAAA;AAAA;AAAA,YALF,eAcE;AAAK,MAAA,SAAS,EAAC,KAAf;AAAA,8BACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cADF,eAEE;AAAK,QAAA,SAAS,EAAC,cAAf;AAAA,+BAGE,QAAC,IAAD;AAAA;AAAA;AAAA;AAAA;AAHF;AAAA;AAAA;AAAA;AAAA,cAFF;AAAA;AAAA;AAAA;AAAA;AAAA,YAdF;AAAA,kBADF;AAyBD,CA/CD,C,CAgDA;AACA;AACA;;;GAlDMD,e;;KAAAA,e;;AAmDN,MAAME,IAAI,GAAG,CAAC;AAACC,EAAAA,EAAD;AAAKC,EAAAA,IAAL;AAAWC,EAAAA,SAAX;AAAsBC,EAAAA;AAAtB,CAAD,KAAsC;AACjD;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAMC,cAAc,GAAGF,SAAS,GAAG,aAAH,GAAmB,EAAnD;AACA,sBACE,QAAC,IAAD;AAAe,IAAA,EAAE,EAAG,IAAGD,IAAK,IAAGD,EAAG,EAAlC;AAAA,2BACE;AAAK,MAAA,SAAS,EAAG,gCAA+BI,cAAe,EAA/D;AAAA,6BAEE;AAAK,QAAA,GAAG,EAAC,EAAT;AAAY,QAAA,GAAG,EAAC;AAAhB;AAAA;AAAA;AAAA;AAAA;AAFF;AAAA;AAAA;AAAA;AAAA;AADF,KAAWJ,EAAX;AAAA;AAAA;AAAA;AAAA,UADF;AAQD,CArBD;;MAAMD,I;AAsBN,SAAQF,eAAR","sourcesContent":["import * as React from 'react'\n// 🐶 importe les ressouces suivantes :\n// import {NetflixAppBar} from './NetflixAppBar'\n// import {NetflixHeader} from './NetflixHeader'\n// import {useFetchData} from '../utils/hooks'\n// import {clientNetFlix, clientApi} from '../utils/clientApi'\n// import * as authNetflix from '../utils/authNetflixProvider'\n// import {TYPE_MOVIE, TYPE_TV, imagePath400} from '../config'\nimport {Link} from 'react-router-dom'\n\n// 🐶 'NetflixBookmark' devra faire deux appels API\n// 1. Le premier vers `bookmark` pour recuperer les favorie\n// 2. Un appel vers API TMDB pour afficher le header\nconst NetflixBookmark = () => {\n  // 🐶 utilise le hook 'useFetchData' et ''useEffect'' pour appeler `bookmark`\n  // 🤖 const {data, execute}\n\n  // 🐶 utilise a nouveau le hook 'useFetchData' et ''useEffect'' pour appeler `TMDV`\n  // pour eviter la collision de nom nous créons des alias pour 'data' et 'execute'\n  // 🤖 const {data: headerMovie, execute: executeHeader}\n\n  // 🐶 appelle 'bookmark' en utilisant\n  React.useEffect(() => {\n    // - execute et clientNetFlix\n    // - await authNetflix.getToken()\n  }, [])\n\n  // 🐶 appelle 'api TMDB' APRES le premier appelle à 'bookmark' grace à la dependance 'data'\n  // et utilise :\n  React.useEffect(() => {\n    // - executeHeader et clientApi\n    // 🐶 utilise le premier films de la liste pour l'appel API TMBD sinon la le film 749274\n    // 🤖 const id = data?.movies?.[0] ?? 749274\n  }, [])\n\n  return (\n    <>\n      {/* 🐶 utilise <NetflixAppBar /> */}\n\n      {/* 🐶 utilise <NetflixHeader type={TYPE_MOVIE} /> */}\n      {/* passe 'headerMovie.data' en prop 'movie' et 'type' 'movie' de <NetflixHeader> */}\n      <div className=\"row\">\n        <h2>Films favoris</h2>\n        <div className=\"row__posters\">\n          {/* 🐶 boucle sur 'data?.bookmark.movies' grace a `.map` et\n        retourne le composant <Card> avec les props 'id' 'type' 'watermark' 'wideImage'*/}\n          <Card />\n        </div>\n      </div>\n\n      <div className=\"row\">\n        <h2>Séries favorites</h2>\n        <div className=\"row__posters\">\n          {/* 🐶 boucle sur 'data?.bookmark.series' grace à `.map` et\n        retourne le composant <Card> avec les props 'id' 'type' 'watermark' 'wideImage'*/}\n          <Card />\n        </div>\n      </div>\n    </>\n  )\n}\n// 🐶 Le composant 'Card' à le même rendu que 'NetflixRow'\n// La difference est qu'au lieu de passer le 'movie' en prop, on passera l'id en props\n// Ensuite avec ce 'id' il faudra appeler l'api TMBD et afficher les donneés.\nconst Card = ({id, type, watermark, wideImage}) => {\n  // 🐶 Créé un state 'image' qui sera mis à jour image' après l'appel d'API\n\n  // 🐶 Fais l'appel API `${type}/${id}`\n\n  // 🐶 utilise useEffect avec la dependance sur 'data' pour mettre à jour l'image\n  // rappel de la fonction 'buildImagePath'\n  // 🤖\n  // const buildImagePath = data => {\n  //   const image = wideImage ? data?.backdrop_path : data?.poster_path\n  //   return image ? `${imagePath400}${image}` : null\n  // }\n  const watermarkClass = watermark ? 'watermarked' : ''\n  return (\n    <Link key={id} to={`/${type}/${id}`}>\n      <div className={`row__poster row__posterLarge ${watermarkClass}`}>\n        {/* 🐶 renseigne correctement src et alt */}\n        <img src=\"\" alt=\"\" />\n      </div>\n    </Link>\n  )\n}\nexport {NetflixBookmark}\n"]},"metadata":{},"sourceType":"module"}